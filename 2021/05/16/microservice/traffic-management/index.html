<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Evan">



    <meta name="description" content="少年书生志气宏">



<title>流量治理 | Evan&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Evan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Evan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">流量治理</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        发表于: <a href="#">五月 16, 2021</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类于:
                            
                                <a href="/categories/microservice/">microservice</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>此文主要是对周志明老师<a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/traffic-management/">相关文章</a>的总结和搬运</p>
</blockquote>
<p>在微服务架构中，服务不是永远稳定的，我们要接受服务总会出错的现实。因此，在微服务的设计中，要有自动的机制能够对其依赖的服务进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。所以<strong>“断路器”这类设施，对实际生产环境的微服务来说，并不是可选的外围组件，而是一个必须的支撑点</strong>。如果没有容错性的设计，系统很容易就会因为一两个服务的崩溃带来的雪崩效应而被淹没。<br>流量治理要解决的两个问题：</p>
<ul>
<li>某一个服务的崩溃，会导致所有用到这个服务的其他服务都无法正常工作，一个点的错误经过层层传递，最终波及到调用链上与此有关的所有服务，这便是雪崩效应。</li>
<li>服务虽然没有崩溃，但由于处理能力有限，面临超过预期的突发请求时，大部分请求直至超时都无法完成处理。这种现象产生的后果跟交通堵塞是类似的，如果一开始没有得到及时地治理，后面就会需要很长时间才能使全部服务都恢复正常。</li>
</ul>
<p>服务容错和流量控制就是解决上述两个问题的方案。</p>
<h1 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h1><h2 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h2><p>容错策略，指的是“面对故障，我们该做些什么”。容错策略大致分为两类：一类是针对错误发生后，应该怎样处理；另一类是在调用之前就开始考虑如何获得最大的成功概率。下面的前5种属于第一类，后2种属于第二类。</p>
<h3 id="故障转移（Failover）"><a href="#故障转移（Failover）" class="headerlink" title="故障转移（Failover）"></a>故障转移（Failover）</h3><p>故障转移是指，如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他服务副本，尝试其他副本能否返回成功调用的结果，从而保证了整体的高可用性。</p>
<p>这种策略需要服务具有幂等性。缺点是故障转移会增加调用时间。</p>
<h3 id="快速失败（Failfast）"><a href="#快速失败（Failfast）" class="headerlink" title="快速失败（Failfast）"></a>快速失败（Failfast）</h3><p>尽快让服务报错并抛出异常，坚决避免重试，由调用者自行处理。</p>
<p>这种策略不需要服务具有幂等性。</p>
<h3 id="安全失败（Failsafe）"><a href="#安全失败（Failsafe）" class="headerlink" title="安全失败（Failsafe）"></a>安全失败（Failsafe）</h3><p>在一个调用链路中的服务，通常也有主路和旁路之分，并不见得每个服务都是不可或缺的，属于旁路逻辑的一个显著特点是，服务失败了也不影响核心业务的正确性。例如日志。</p>
<p>属于旁路逻辑的另一个显著特征是，后续处理不会依赖其返回值，或者它的返回值是什么都不会影响后续处理的结果。</p>
<p>对这类逻辑，一种理想的容错策略是，即使旁路逻辑调用失败了，也当作正确来返回，如果需要返回值的话，系统就自动返回一个符合要求的数据类型的对应零值，然后自动记录一条服务调用出错的日志备查即可。</p>
<h3 id="沉默失败（Failsilent）"><a href="#沉默失败（Failsilent）" class="headerlink" title="沉默失败（Failsilent）"></a>沉默失败（Failsilent）</h3><p>如果大量的请求需要等到超时（或者长时间处理后）才宣告失败，很容易因为某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定性。面对这种情况，一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，并将错误隔离开来，避免对系统其他部分产生影响。</p>
<h3 id="故障恢复（Failback）"><a href="#故障恢复（Failback）" class="headerlink" title="故障恢复（Failback）"></a>故障恢复（Failback）</h3><p>故障恢复是指，当服务调用出错了以后，将该次调用失败的信息存入一个消息队列中，然后由系统自动开始异步重试调用。</p>
<p>故障恢复也是需要服务具有幂等性，由于它的重试是后台异步进行，即使最后调用成功了，原来的请求也早已经响应完毕。所以，故障恢复策略一般用于对实时性要求不高的主路逻辑，也适合处理那些不需要返回值的旁路逻辑。</p>
<h3 id="并行调用（Forking）"><a href="#并行调用（Forking）" class="headerlink" title="并行调用（Forking）"></a>并行调用（Forking）</h3><p>并行调用策略，是指一开始就同时向多个服务副本发起调用，只要有其中任何一个返回成功，那调用便宣告成功。</p>
<h3 id="广播调用（Broadcast）"><a href="#广播调用（Broadcast）" class="headerlink" title="广播调用（Broadcast）"></a>广播调用（Broadcast）</h3><p>广播调用与并行调用是相对应的，都是同时发起多个调用，但并行调用是任何一个调用结果返回成功便宣告成功，而广播调用则是要求所有的请求全部都成功，才算是成功。</p>
<h2 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h2><p>容错设计模式，指的是“要实现某种容错策略，我们该如何去做”。</p>
<h3 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h3><p>断路器做的事情是自动进行服务熔断，属于一种快速失败的容错策略的实现方法。断路器一般可以设置为 CLOSED、OPEN 和 HALF OPEN 三种状态。</p>
<ul>
<li><p>在断路器刚刚建立的时候，默认是CLOSED状态。此时的远程请求会真正发送给服务提供者，此后将持续监视远程请求的数量和执行结果，决定是否要进入 OPEN 状态。</p>
</li>
<li><p>当断路器监控到<strong>单位时间</strong>内，达到<strong>一定数量的请求</strong>的<strong>故障率</strong>超过阈值，断路器会变为OPEN状态。此时不会进行远程请求，直接给服务调用者返回调用失败的信息。直接进行<strong>熔断</strong>。Netflix Hystrix对着三个参数的默认值分别是：10 秒、20 个请求、50%。</p>
</li>
<li><p>断路器必须带有自动的故障恢复能力，当进入 OPEN 状态一段时间以后，将“自动”（一般是由下一次请求而不是计时器触发的，所以这里的自动是带引号的）切换到 HALF OPEN 状态。在中间状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，来实现断路器的弹性恢复。</p>
</li>
</ul>
<h4 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h4><p>这两个是服务治理中非常容易混淆的概念。断路器做的事情是自动进行服务熔断，将故障信息反馈给上游服务，而上游服务必须能够主动<strong>处理</strong>调用失败的后果，而不是坐视故障扩散。这里的“处理”，指的就是一种典型的服务降级逻辑。</p>
<p>服务降级不一定是在出现错误后才被动执行的，我们在很多场景中谈论的降级更可能是指，需要主动迫使服务进入降级逻辑的情况。</p>
<h3 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h3><p>除了服务熔断和服务降级，服务治理中还有另一个很常见的概念：<strong>服务隔离</strong>。</p>
<p>舱壁隔离模式，是常用的实现服务隔离的设计模式。服务隔离，就是避免某一个远程服务的局部失败影响到全局，而设置的一种止损方案。这种思想，对应的就是容错策略中的<strong>沉默失败</strong>策略。</p>
<p>以一个Java Web应用为例，整个应用的所有接口共享的是Tomcat配置的线程池，一般在200到400之间。如果某个接口由于某些原因发生了<strong>超时</strong>的问题，如果调用者短时间内对这个接口发起了“疯狂”的请求，那么很快，整个应用的线程都会被这个接口“吃掉”。此时整个应用都被这个发生问题的接口拖累的无法对外提供服务了。</p>
<p>发生这种问题的根本原因在于，整个应用共享了一个线程池。如果针对各个接口，设置独立的线程池。这样因为某个接口产生的超时问题，便不会影响到整个应用。</p>
<p>但是，局部线程池有一个显著的弱点，那就是它额外增加了 CPU 的开销，每个独立的线程池都要进行排队、调度和下文切换工作。根据 Netflix 官方给出的数据，一旦启用 Hystrix 线程池来进行服务隔离，每次服务调用大概会增加 3~10 毫秒的延时。如果调用链中有 20 次远程服务调用的话，那每次请求就要多付出 60 毫秒至 200 毫秒的代价，来换取服务隔离的安全保障。</p>
<p>为应对这种情况，还有一种更轻量的控制服务最大连接数的办法，那就是<strong>信号量机制（Semaphore）</strong>。</p>
<p>如果不考虑清理线程池、客户端主动中断线程这些额外的功能，仅仅是为了控制单个服务并发调用的最大次数的话，我们可以只为每个远程服务维护一个线程安全的计数器，并不需要建立局部线程池。</p>
<p>服务隔离的思想不仅可以按照某个接口这样进行划分，可以根据各种各样的划分逻辑，站在更高的层次去保障整个系统的可用性。</p>
<h3 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h3><p>故障转移和故障恢复这两种策略都需要对服务进行重复调用，差别就在于这些重复调用有可能是同步的，也可能是后台异步进行；有可能会重复调用同一个服务，也可能会调用服务的其他副本。但是重点都在于重试。</p>
<p>重试模式适合解决系统中的瞬时故障，简单地说就是有可能自己恢复（Resilient，称为自愈，也叫做回弹性）的临时性失灵，比如网络抖动、服务的临时过载（比如返回了 503 Bad Gateway 错误）这些都属于瞬时故障。</p>
<p>实现重试很简单，如果是Spring应用，使用Spring Retry一个注解就可以搞定了，但是在实现重试模式时要注意：</p>
<ol>
<li>是否有必要重试</li>
<li>是否应该重试</li>
<li>是否可以重试（幂等性）</li>
<li>何时终止（超时终止、次数终止）</li>
</ol>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="流量统计指标"><a href="#流量统计指标" class="headerlink" title="流量统计指标"></a>流量统计指标</h2><ul>
<li>每秒事务数（Transactions per Second，TPS）：TPS是衡量信息系统吞吐量的最终标准。“事务”可以理解为一个逻辑上具备原子性的业务操作。</li>
<li>每秒请求数（Hits per Second，HPS）：HPS是指每秒从客户端发向服务端的请求数。如果只要一个请求就能完成一笔业务，那HPS与TPS是等价的。</li>
<li>每秒查询数（Queries per Second，QPS）：QPS是指一台服务器能够响应的查询次数。如果只有一台服务器来应答请求，那QPS和HPS是等价的。QPS和HPS相比，QPS是针对某个服务器来说的，HPS是站在客户端角度，是针对整个系统而言。</li>
</ul>
<p>目前来说，主流系统大多倾向于使用 <strong>HPS</strong> 作为首选的限流指标，因为它相对容易观察统计，而且能够在一定程度上反映系统当前以及接下来一段时间的压力。</p>
<h2 id="限流设计模式"><a href="#限流设计模式" class="headerlink" title="限流设计模式"></a>限流设计模式</h2><p>限流也大致分为两类：否决式限流、阻塞式限流。前两种模式就适用于否决式限流。</p>
<h3 id="流量计数器模式"><a href="#流量计数器模式" class="headerlink" title="流量计数器模式"></a>流量计数器模式</h3><p>设置一个计算器，根据当前时刻的流量计数结果是否超过阈值来决定是否限流。它的缺点是只是针对时间点进行离散的统计。比如一个80TPS的系统，可能在每一秒内都没有超过80TPS，将两秒的流量连续起来看，很有可能在中间时间段内超过了80TPS。</p>
<h3 id="滑动时间窗模式"><a href="#滑动时间窗模式" class="headerlink" title="滑动时间窗模式"></a>滑动时间窗模式</h3><p>为了解决上面的问题，很自然想到可以实现平滑的基于时间片段统计。滑动时间窗口模式就是如此。和TCP的滑动窗口很像。</p>
<h3 id="漏桶模式"><a href="#漏桶模式" class="headerlink" title="漏桶模式"></a>漏桶模式</h3><p>漏桶在代码实现上非常简单，它其实就是一个以请求对象作为元素的先入先出队列（FIFO Queue），队列长度就相当于漏桶的大小，当队列已满时便拒绝新的请求进入。</p>
<p>漏桶实现起来很容易，困难在于如何确定漏桶的两个参数：桶的大小和水的流出速率。现实中系统的处理速度往往受到其内部拓扑结构变化和动态伸缩的影响，所以能够支持变动请求处理速率的令牌桶算法往往可能会是更受程序员青睐的选择。</p>
<h3 id="令牌桶模式"><a href="#令牌桶模式" class="headerlink" title="令牌桶模式"></a>令牌桶模式</h3><p>它与漏桶一样都是基于缓冲区的限流算法，只是方向刚好相反，漏桶是从水池里往系统出水，令牌桶则是系统往排队机中放入令牌。当桶中的令牌没有了，就应该马上失败或进入服务降级逻辑。与漏桶类似，令牌桶同样有最大容量，这意味着当系统比较空闲时，桶中令牌累积到一定程度就不再无限增加，预存在桶中的令牌便是请求最大缓冲的余量。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"># 服务治理</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/05/17/microservice/hystrix/">Hystrix实现原理</a>
            
            
            <a class="next" rel="next" href="/2021/02/23/os/zero-copy/">Linux零拷贝技术</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Evan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
 -->
    </div>
</body>
</html>
