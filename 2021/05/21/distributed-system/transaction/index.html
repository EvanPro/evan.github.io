<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Evan">



    <meta name="description" content="少年书生志气宏">



<title>分布式事务 | Evan&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Evan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Evan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">分布式事务</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        发表于: <a href="#">五月 21, 2021</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类于:
                            
                                <a href="/categories/distributed-system/">distributed system</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>从单机的数据库事务变成分布式事务时，原有单机中相对可靠的方法调用以及进程间通信方式已经没有办法使用，同时由于网络通信经常是不稳定的，所以服务之间信息的传递会出现障碍。</p>
<p>模块（或服务）之间通信方式的改变是造成分布式事务复杂的最主要原因，在同一个事务之间的执行多段代码会因为网络的不稳定造成各种奇怪的问题，当我们通过网络请求其他服务的接口时，往往会得到三种结果：正确、失败和超时，无论是成功还是失败，我们都能得到唯一确定的结果，<strong>超时代表请求的发起者不能确定接受者是否成功处理了请求</strong>，这也是造成诸多问题的诱因。<br>同单机事务一样，<strong>各种形式的日志是保证事务几大特性的重要手段</strong>。</p>
<h1 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h1><p>相信大部分人开始接触事务应该都是通过数据库，我们的应用配置一个数据源，直接操作JDBC api或者借助一些框架比如spring的帮助完成事务的操作，这一切都借助于数据库提供的事务能力。这种场景就是最普遍的”单个服务使用单个数据源“的场景。</p>
<p>本地事务（Local Transaction）也叫局部事务，是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。它是能满足ACID的强一致性事务。具体的实现，可以参考Mysql数据库对事务的实现方式。</p>
<h1 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h1><p>共享事务主要是针对“多个服务使用单个数据源”场景。以我参与的一个微服务项目为例，在项目初期，我们划分出了多个微服务，例如教学服务和实验服务等等，理论上来说，每一个微服务都应该配置自己的数据库实例，但是因为项目早期的流量不会很多，而且配置多个数据库实例维护起来也很麻烦。所以我们的处理方式是所有的微服务共享同一个数据库实例，只不过各个微服务的表都是以各自微服务名为前缀，并且不允许跨不同前缀的表进行join操作。</p>
<p>可以看出来，这是一个过渡期的方案，因为随着微服务数量的增加，数据库链接的压力会变得越来越大，所以最终一定会将各个微服务的数据库实例分离。因此，如果我们的业务有跨微服务的事务需求，那么我们一定会使用分布式事务去解决。但是，看了周志明老师关于共享事务的文章，提供了另外一种思路。虽然我觉得最终还是不会使用共享事务，但是看一看还是比较有意思的。</p>
<p>为了实现共享事务，就必须新增一个“交易服务器”的中间角色，无论是教学服务、实验服务还是内容服务，它们都通过同一台交易服务器来与数据库打交道。如果将交易服务器的对外接口按照JDBC规范来实现的话，那它完全可以视为是一个独立于各个服务的远程数据库连接池，或者直接作为数据库代理来看待。此时三个服务所发出的请求就有可能做到交由交易服务器上的同一个数据库连接，通过本地事务的方式完成。</p>
<p>除了上述方案，还可以使用消息队列服务器的来代替交易服务器，通过消息将所有对数据库的改动传送到消息队列服务器，通过消息的消费者来统一处理，实现由本地事务保障的持久化操作。</p>
<p>虽然有点意思，但是如果我来做决策，我肯定不用~</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>在分布式架构的场景下，完成某一个业务可能需要横跨多个服务，操作多个数据源。这其中又大概分为两种场景，一种是”一个服务操作多个数据源“，一种是”多个服务操作多个数据源“。但是无论是哪种场景，都需要一个<strong>分布式事务一致性协议</strong>来保证所有节点在进行事务提交时保持一致性。分布式事务通常采用二阶段提交协议（2PC）,<strong>它是几乎所有分布式事务算法的基础</strong>。</p>
<h2 id="刚性事务"><a href="#刚性事务" class="headerlink" title="刚性事务"></a>刚性事务</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>在一个分布式系统中，所有的节点虽然都可以知道自己执行操作后的状态，但是无法知道其他节点执行操作的状态，因此需要引入一个作为<strong>协调者</strong>的组件来统一调度全部的节点是否把操作结果进行真正的提交，这些被调度的节点称为<strong>参与者</strong>。</p>
<p>两阶段提交的执行过程就跟它的名字一样分为两个阶段，<strong>投票阶段</strong>和<strong>提交阶段</strong>。概括来说就是，参与者将操作成败通知协调者（投票阶段），再由协调者根据所有参与者的反馈决定各参与者是否要提交操作或者中止操作。</p>
<p>2PC能工作是有前提的：</p>
<ul>
<li>该分布式系统中，存在一个节点作为<strong>协调者</strong>（Coordinator），其他节点作为<strong>参与者</strong>（Participants）。且节点之间可以进行网络通信。</li>
<li>所有节点都采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97">预写式日志</a>，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<p>对于上面的3个前提，我的理解是，2PC允许在事务执行过程中发生错误，但是这些错误必须都是<strong>临时性的错误</strong>，无论是进程错误、网络错误等等都应该是可以恢复的。</p>
<h4 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h4><p>在投票阶段中，协调者（Coordinator）会向事务的参与者（Cohort）询问是否可以执行操作的请求，并等待其他参与者的响应，参与者会<strong>执行</strong>相对应的事务操作，所有<strong>执行成功</strong>的参与者会向协调者发送 <code>AGREEMENT</code> 或者 <code>ABORT</code> 表示执行操作的结果。</p>
<img src="/2021/05/21/distributed-system/transaction/2pc-voting.png" class="">

<h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><p>当所有的参与者都返回了确定的结果（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向将事务状态置为<code>commit</code>或者<code>abort</code>状态，然后向所有的参与者发送提交或者回滚的指令。</p>
<img src="/2021/05/21/distributed-system/transaction/2pc-commit.png" class="">

<p>当事务的所有参与者都决定提交事务时，协调者会向参与者发送 <code>COMMIT</code> 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 <code>ABORT</code> 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会进行回滚，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>2PC最大的问题在于它是一个阻塞协议，如果协调者发生了永久性宕机，一些参与者可能永远也无法处理他们的事务。比如，当一个参与者向协调者发送了一个<code>AGREEMENT</code>，然后协调者宕机了，那么这个参与者会永远阻塞，直到收到<code>COMMIT</code>或者<code>ABORT</code>请求。</p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>2PC协议在下面这种情况下无法可靠地恢复事务状态：如果协调者和一个参与者在<strong>提交阶段</strong>都发生了failure。如果仅仅是协调者宕了，还没有任何一个参与者收到 <code>COMMIT</code> 了请求，那么不会有什么问题，所有参与者回滚就好了。但是如果协调者和一个参与者都发生了宕机，并且这个参与者是第一个被协调者通知<code>COMMIT</code>或者<code>ABORT</code>请求的，那么就算新选出一个协调者，整个系统也会出现数据不一致的情况。因为首先上一个协调者宕机了导致投票阶段的结果已经丢失，其次第一个被通知投票结果的参与者也宕机了，这样整个集群永远无法直到上一次投票的结果是什么，剩下的参与者无论做<code>COMMIT</code>或者<code>ROLLBACK</code>都有可能和第一个已经宕机的参与者不一致。</p>
<p>上述场景的问题根源在于，所有参与者投票的结果只有协调者知道，这样当协调者宕机并且已经有参与者执行了投票结果并且也发生了宕机之后，其他还未接收到投票结果的参与者就会无所适从。</p>
<p>解决思路也很自然，就是将投票阶段产生的投票结果在协调者和所有参与者上都保存。为了达到这一目的，就需要增加一个<strong>pre-commit</strong>阶段。</p>
<img src="/2021/05/21/distributed-system/transaction/Three-phase_commit_diagram.png" class="">

<p>新增的<strong>pre-commit</strong>阶段完成后，所有的参与者就都知道其他参与者的真实意图了，那么我们再来看看上面2PC发生问题的场景在3PC里会怎么样：当<strong>commit</strong>阶段开始时，无论是协调者还是有的参与者发生了宕机，继任的协调者都可以通过询问参与者，如果有的参与者已经处于<strong>commit</strong>阶段了，那就证明上一任协调者已经发送了<code>doCommit</code>请求，因此继续执行<code>doCommit</code>即可。如果有任何一个参与者反馈没有受到过preCommit请求，那么证明上一任协调者<strong>pre-commit</strong>阶段，那么其他参与者也一定没有真正的提交。</p>
<h3 id="XA事务"><a href="#XA事务" class="headerlink" title="XA事务"></a>XA事务</h3><p>针对“单个服务使用多个数据源”的场景，可以使用XA协议。XA是一套语言无关的通用规范。可以认为XA是对2PC的传统实现。Java中专门定义JTA（Java Transaction API）对XA进行支持。现在比较轻量的实现有<a target="_blank" rel="noopener" href="http://www.atomikos.com/Main/TransactionsEssentials">Atomikos</a>。XA协议是根据2PC实现的，内部分为两种角色：事务管理器（TM）相当于协调者，资源管理器（RM）相当于参与者。</p>
<img src="/2021/05/21/distributed-system/transaction/dtp.png" class="">

<p>XA确实能够保证较强的一致性，但是使用并不广泛，一个是因为性能，一个是因为并不是所有的资源都支持XA协议。</p>
<h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>严格的ACID事务对隔离性的要求很高，在事务执行中必须将所有的资源锁定，对于长事务来说，整个事务期间对数据的独占，将严重影响系统并发性能。因此，在高并发场景中，对ACID的部分特性进行放松从而提高性能，这便产生了BASE柔性事务。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面，通过放宽对强一致性要求，来换取系统吞吐量的提升。另外提供自动的异常恢复机制，可以在发生异常后也能确保事务的最终一致。</p>
<p>由于CAP定理的存在，因为P是分布式网络的天然属性，你再不想要也无法丢弃，而A通常是建设分布式的目的，所以除非银行、证券这些涉及金钱交易的服务，其余大部分系统都可以为了增加系统的吞吐量以及可用性逐渐降低了系统对一致性的要求，只要求最终一致性。  </p>
<p>需要注意的是，CAP中的一致性和ACID中的一致性并不是一个含义：ACID中的一致性是指在一系列对数据修改的操作中，保证数据的正确性；而分布式环境中的一致性是指对<strong>同一个数据多个副本间的读写一致性</strong>。我们接下来讨论中的一致性主要是CAP中所代表的一致性。</p>
<h3 id="最大努力交付（Best-effort-Delivery）"><a href="#最大努力交付（Best-effort-Delivery）" class="headerlink" title="最大努力交付（Best-effort Delivery）"></a>最大努力交付（Best-effort Delivery）</h3><p>最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如支付通知、短信通知等。<br>以我做过的一个聚合支付系统为例：</p>
<ol>
<li>用户调用我们的接口进行付款，我们的支付服务会在数据库中生成一条订单的记录，状态置为PENDING，提交事务。</li>
<li>然后调用第三方支付平台（比如支付宝）的支付接口。</li>
<li>当用户支付完成后，第三方支付平台会回调我们的接口通知我们支付状态，我们会根据回调信息更新数据库，并ACK第三方支付平台，从而达到数据的最终一致性。</li>
<li>如果第三方支付平台没有收到我们的ACK，那么会间隔一段时间进行重试。</li>
<li>如果因为某些原因，直至超过重试次数，我们依然没有收到第三方支付平台的回调，那么我们会主动调用第三方支付平台的查询接口，从而达到数据的最终一致性。</li>
</ol>
<p>如果支付平台由我们自己写的话，那可以使用MQ，例如RocketMQ实现上面第三方支付平台实现的通知逻辑。  </p>
<h3 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h3><p>可靠消息最终一致性方案是指当<strong>事务发起方执行完成本地事务后并发出一条消息</strong>，事务参与方(消息消费者)一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。<br>其核心原理是将两个事务通过消息中间件进行异步解耦。既然通过消息中间件进行解耦，那么就一定会涉及到网络调用。</p>
<img src="/2021/05/21/distributed-system/transaction/reliable-msg.png" class="">
<p>可靠消息的可靠是指两方面，首先事务发起方的本地事务与消息投递是<strong>原子性</strong>的，其次消息必须是<strong>持久化</strong>的。<br>关于原子性，正常思路自然是如下代码，但是问题就出在第2步发送MQ上，前面说过通过网络请求其他服务的接口时，往往会得到三种结果：正确、失败和超时。如果发生了超时，那么下面的代码就有可能导致不一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin transaction； </span><br><span class="line">    &#x2F;&#x2F;1.数据库操作 </span><br><span class="line">    &#x2F;&#x2F;2.发送MQ </span><br><span class="line">commit transation;</span><br></pre></td></tr></table></figure>
<p>所以就需要通过重试来解决超时等网络问题，下面来看两种解决方案。</p>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>本地消息表最早是由eBay的架构师提出的，此处借用朱小厮老师的图描述下本地消息表的流程：</p>
<img src="/2021/05/21/distributed-system/transaction/local-msg-table.png" class="">
<p>本地消息表的解决方案使用数据库来保证消息的可靠投递，写入业务表的逻辑和写入消息表（记录事务状态）的逻辑在同一个事务中，这样通过本地事务保证了一致性。之后，事务主动方将所要发送的消息发送到消息中间件中（步骤3）。消息在发送过程中丢失了怎么办？这里就体现出消息表的用处了。在上一步中，在消息表中记录的消息状态是“发送中”，事务主动方可以定时扫描消息表，然后将其中状态为“发送中”的消息重新投递到消息中间件即可。只有当最后事务被动方消费完之后，消息的状态才会被设置为“已完成”。<br>前面3个步骤可以避免“业务处理成功，消息发送失败”或者“消息发送成功，业务处理失败”这种棘手情况的出现，并且也可以保证消息不会丢失。<br>此方案优点在于简单，而缺点在于本地消息表与业务耦合，并且基于数据库写磁盘，高并发下性能有瓶颈。</p>
<h4 id="RocketMQ事务消息（Transactional-Message）"><a href="#RocketMQ事务消息（Transactional-Message）" class="headerlink" title="RocketMQ事务消息（Transactional Message）"></a>RocketMQ事务消息（Transactional Message）</h4><p>与本地消息表类似，使用MQ的事务消息只是对本地消息表的封装，其MQ内部实现了本地消息表的功能。目前只有RocketMQ可以实现事务消息。<br>先来看看为什么使用RabbitMQ没有办法实现事务消息。RabbitMQ通过发送方确认机制和事务可以保证消息发送到RabbitMQ中。但是RabbitMQ无法保证本地事务与消息发送的原子性，比如事务发起方在提交本地事务后宕机，那么消息就不会被发送到RabbitMQ中。<br>RocketMQ在4.3.0版中已经支持分布式事务消息，RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息。</p>
<img src="/2021/05/21/distributed-system/transaction/rocketmq.webp" class="">
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<ol>
<li>事务消息发送及提交：<ol>
<li>发送消息（half消息，对用户不可见）</li>
<li>服务端响应消息写入结果</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）</li>
<li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</li>
</ol>
</li>
<li>补偿流程：<ol>
<li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li>
<li>Producer收到回查消息，检查回查消息对应的本地事务的状态</li>
<li>根据本地事务状态，重新Commit或者Rollback</li>
</ol>
</li>
</ol>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="与最大努力交付的对比"><a href="#与最大努力交付的对比" class="headerlink" title="与最大努力交付的对比"></a>与最大努力交付的对比</h4><p>这两种方案都适合上游事务对下游事务无依赖的场景。只要上游业务（消息中间件之前的业务）完成了，后续就<strong>没有失败回滚</strong>的概念，只许成功，不许失败。如果确实存在下游业务需要回滚，那么需要业务介入。不同的是最终下游业务能达成数据的最终一致性，可靠消息是由上游业务确保消息的投递，而最大努力交付是靠下游业务自己在消息投递失败时进行主动查询。</p>
<h3 id="TCC（Try-Confirm-Cancel）"><a href="#TCC（Try-Confirm-Cancel）" class="headerlink" title="TCC（Try-Confirm-Cancel）"></a>TCC（Try-Confirm-Cancel）</h3><p>TCC（Try-Confirm-Cancel）最早是由数据库专家Pat Helland在2007年提出。它的优势在于可以提供事务的<strong>隔离性</strong>，如果业务需要隔离，那架构师通常就应该重点考虑TCC方案，该方案天生适合用于需要强隔离性的分布式事务中。<br>在具体实现上，TCC较为烦琐，它是一种业务侵入式较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程。它分为以下三个阶段：</p>
<ul>
<li>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li>
<li>Confirm：确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理。Confirm阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li>
<li>Cancel：取消执行阶段，释放Try阶段预留的业务资源。Cancel阶段可能会重复执行，也需要满足幂等性。</li>
</ul>
<p>与传统2PC相比，TCC不再需要RM的参与，而是将RM原本的工作（响应TM的Commit/Rollback）交给了业务系统，由业务系统提供相应的提交回滚接口。在2PC中，prepare阶段需要锁住资源，不能进行真正的提交，而TCC在try、confirm、cancle三个阶段都可以本地提交。因此TCC可以根据需要设计资源锁定的粒度，实现了较高的灵活性。  </p>
<img src="/2021/05/21/distributed-system/transaction/tcc.png" class="">
<p>以转账业务来说，假设主服务先调用A服务给张三的账户扣钱，然后调用B服务给李四账户加钱。</p>
<ol>
<li>那么可以在A服务的try阶段直接扣钱然后进行本地事务提交而comfirm阶段什么也不做，因为try阶段已经“预留了业务资源”。</li>
<li>而B服务因为加钱操作不太涉及资源竞争，所以可以在try阶段什么也不用，而在confirm阶段进行真正的加钱操作。</li>
<li>如果因为出错，进入到了concel阶段，那么直接执行A服务的加钱和B服务的减钱操作即可。</li>
</ol>
<h4 id="TCC需要注意的三种异常处理"><a href="#TCC需要注意的三种异常处理" class="headerlink" title="TCC需要注意的三种异常处理"></a>TCC需要注意的三种异常处理</h4><h5 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h5><p>幂等的含义很简单，重复调用多次产生的业务结果与调用一次产生的业务结果相同。幂等其实不知是TCC需要注意的，一切采用重试机制的分布式事务都需要注意幂等。</p>
<h5 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h5><p>需要在Cancel方法中处理空回滚的情况。<br>在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法，Cancel方法需要识别出这是一个空回滚，然后直接返回成功。出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行Try阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。<br>解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。前面已经说过TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张分支事务记录表，其中有全局事务ID和分支事务ID，第一阶段Try方法里会插入一条记录，表示一阶段执行了。Cancel接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p>
<h5 id="悬挂"><a href="#悬挂" class="headerlink" title="悬挂"></a>悬挂</h5><p>需要在Try方法中处理悬挂的情况。<br>悬挂就是对于一个分布式事务，第二阶段Cancel接口比Try接口先执行。出现的原因是由于网络阻塞，Try请求超时了（但是这时全局事务的try记录已经存在），触发了Cancel方法并且执行完成，然后Try请求才到达。<br>解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行Try。</p>
<h3 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/">周志明凤凰架构</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/distributed-transaction-principle/">分布式事务的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://honeypps.com/architect/introduction-of-distributed-transaction/">分布式事务科普</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XA-CsdBxgbXdsIjKOdyoGQ">如何通过事务消息保障抢购业务的分布式一致性？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">rocketmq 设计</a></li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E4%BA%8B%E5%8A%A1/"># 事务</a>
                    
                        <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"># 分布式事务</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2021/05/17/microservice/hystrix/">Hystrix实现原理</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Evan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
 -->
    </div>
</body>
</html>
