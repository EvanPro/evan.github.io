<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Evan">



    <meta name="description" content="少年书生志气宏">



<title>MVCC | Evan&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Evan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Evan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">MVCC</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        发表于: <a href="#">七月 2, 2020</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类于:
                            
                                <a href="/categories/MySQL/">MySQL</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>MVCC</strong>是MySQL中一种针对<em>读操作</em>的优化方案。MVCC 并不是一个与乐观和悲观并发控制对立的东西，它能够与两者很好的结合以增加事务的并发量，在目前最流行的 SQL 数据库 MySQL 和 PostgreSQL 中都对 MVCC 进行了实现。<br>它的基本原理就是每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回。在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p>
<h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p>
<ul>
<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>每次对记录进行改动，都会记录一条undo log，每条undo log也都有一个roll_pointer属性，可以将这些undo日志都连起来，串成一个链表，就像下图一样：</p>
<img src="/2020/07/02/mysql/mvcc/versionchain.png" class="">
<p>版本链的头节点就是当前记录最新的值。</p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>ReadView可以简单理解为快照。针对不同的事务隔离级别，MVCC的核心原理就是：当一个事务读取某个记录时，需要判断一下版本链中的哪个版本是当前事务可见的。为此，就有了ReadView的概念，ReadView中主要包含4个比较重要的内容：</p>
<ul>
<li>m_ids：表示在<strong>生成</strong>ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>min_trx_id：m_ids中的最小值。</li>
<li>max_trx_id：表示<strong>生成</strong>ReadView时系统中应该分配给下一个事务的id值。max_trx_id并不是m_ids中的最大值，事务id是递增分配的。</li>
<li>creator_trx_id：表示<strong>生成</strong>该ReadView的事务的事务id。</li>
</ul>
<p>简单理解就是m_ids是一个事务id区间为<code>[min_trx_id,max_trx_id)</code>的列表。<br>有了ReadView，在访问某个版本时，只需要从版本链开始按照下边的步骤遍历记录（undo log），找到第一个可见的版本数据就好了：</p>
<ul>
<li>如果版本的trx_id等于当前事务的id，那么意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果版本的trx_id 小于 [min_trx_id,max_trx_id) 区间的下界，表明生成该版本的事务在当前事务生成ReadView前<strong>已经提交</strong>，所以该版本<strong>可以</strong>被当前事务访问。</li>
<li>如果版本的trx_id 大于 [min_trx_id,max_trx_id) 区间的上界，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本<strong>不可以</strong>被当前事务访问。</li>
<li>如果版本的trx_id 在 [min_trx_id,max_trx_id) 区间内，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>所以可以看到，当一个事务生成ReadView，那么这个事务可以看到自己修改的数据，可以看到在生成ReadView这一刻，其他已经提交的事务修改的数据。其余的情况是看不到的。<br>在MySQL中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们<strong>生成ReadView的时机不同</strong>。</p>
<h2 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h2><p>读已提交是不允许发生<strong>脏读</strong>的，也就是不可以读到其他未提交的事务修改的数据。但是可能发生<strong>不可重复读</strong>和<strong>幻读</strong>问题，每次其他事务更新了数据并提交都可以读的到。因此读已提交隔离级别会<strong>在每一次进行普通SELECT操作前都生成一个ReadView</strong>。注意是<strong>每次</strong>都会。</p>
<h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h2><p>可重复读是在读已提交的基础上，<strong>不可重复读</strong>也是不允许的，MySQL的实现，连<strong>幻读</strong>也可以避免。因此可重复读隔离级别会<strong>只在第一次进行普通SELECT操作前生成一个ReadView</strong>，之后的查询操作都重复使用这个ReadView。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/MySQL/"># MySQL</a>
                    
                        <a href="/tags/%E4%BA%8B%E5%8A%A1/"># 事务</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/07/03/mysql/lock/">MySQL中的锁</a>
            
            
            <a class="next" rel="next" href="/2020/07/01/mysql/transaction/">MySQL数据库事务</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Evan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
 -->
    </div>
</body>
</html>
